---
# ==================== АУТЕНТИФИКАЦИЯ ====================
# Включить multi-tenancy (мульти-арендность)?
# Что это? Loki может изолировать логи разных "арендаторов" (tenant).
# Почему false? Для тестирования это избыточно.
# Когда включать? Production с несколькими командами/проектами.
auth_enabled: false

# ==================== SERVER ====================
server:
  # IP адрес для прослушивания HTTP запросов
  # Почему 0.0.0.0? Слушаем на всех интерфейсах (доступен из других контейнеров)
  # Альтернатива: 127.0.0.1 (только localhost, не подходит для Docker)
  http_listen_address: 0.0.0.0

  # HTTP порт
  # Почему 3100? Стандартный порт Loki (как 3306 для MySQL)
  http_listen_port: 3100

  # Уровень логирования самого Loki
  # Уровни: debug, info, warn, error
  # Почему info? Достаточно для тестирования, не засоряет логи.
  # debug - если нужна отладка самого Loki
  log_level: info

# ==================== COMMON (общие настройки) ====================
common:
  # Префикс пути для всех данных Loki
  # Почему /loki? Просто соглашение. Можно /data или что угодно.
  path_prefix: /loki

  # ==================== STORAGE (хранилище) ====================
  storage:
    # Тип хранилища: filesystem (локальные файлы)
    # Альтернативы:
    # - s3: Amazon S3 или MinIO (для production)
    # - gcs: Google Cloud Storage
    # - azure: Azure Blob Storage
    # Почему filesystem? Проще для тестирования, не нужен MinIO.
    filesystem:
      # Директория для chunks (кусочков логов)
      # Что такое chunks? Loki разбивает логи на маленькие файлы (chunks).
      # Почему /loki/chunks? Внутри контейнера, смонтирован в volume.
      chunks_directory: /loki/chunks

      # Директория для rules (правила алертов)
      # Что такое rules? Правила для отправки уведомлений (alerts).
      # Пример: "если 10 ERROR за минуту → отправить в Slack"
      # Пока не используем, но директория нужна.
      rules_directory: /loki/rules

  # Фактор репликации
  # Что это? Сколько копий данных хранить.
  # Почему 1? У нас один Loki instance, репликация не нужна.
  # В production: 3 (для надежности)
  replication_factor: 1

  # ==================== RING (координация между Loki instances) ====================
  ring:
    # IP адрес этого Loki instance
    # Почему 127.0.0.1? У нас один instance, координация не нужна.
    # В microservices mode: реальный IP контейнера
    instance_addr: 127.0.0.1

    # Key-Value store для координации
    # Типы: inmemory, consul, etcd, memberlist
    # Почему inmemory? Простейший вариант, данные в памяти.
    # В production: consul или etcd (для надежности)
    kvstore:
      store: inmemory

# ==================== SCHEMA CONFIG (схема индексов) ====================
schema_config:
  configs:
    # Начиная с какой даты использовать эту схему
    # Почему 2024-01-01? Любая дата в прошлом.
    # Если изменить схему → новая дата + новая конфигурация.
    - from: 2024-01-01

      # Тип индекса: tsdb (Time Series Database)
      # Альтернативы: boltdb (старый), boltdb-shipper
      # Почему tsdb? Новый, быстрый, рекомендуется Grafana Labs.
      store: tsdb

      # Хранилище для chunks
      # Почему filesystem? Соответствует common.storage
      object_store: filesystem

      # Версия схемы
      # Почему v13? Последняя стабильная версия.
      # v12, v11 - старые, не используйте.
      schema: v13

      # Настройки индекса
      index:
        # Префикс имени индекса
        # Почему index_? Просто соглашение, можно изменить.
        # Итоговое имя: index_19999 (где 19999 - период)
        prefix: index_

        # Период индекса (каждые 24 часа новый индекс)
        # Почему 24h? Баланс между количеством индексов и производительностью.
        # Альтернативы:
        # - 168h (7 дней) - меньше индексов, медленнее поиск
        # - 12h - больше индексов, быстрее поиск, больше overhead
        period: 24h

# ==================== LIMITS CONFIG (лимиты) ====================
limits_config:
  # Период хранения логов
  # Почему 168h (7 дней)? Для тестирования достаточно.
  # Production: 720h (30 дней) или больше.
  # После этого периода логи удаляются compactor'ом.
  retention_period: 168h

  # Максимальная скорость приема логов (MB/sec на tenant)
  # Почему 50? Достаточно для тестирования.
  # Пример: 50MB/sec = 4,320,000 MB/день = 4.32 TB/день
  # Если превышено → Loki откажет в записи логов.
  ingestion_rate_mb: 50

  # Burst размер (пиковая нагрузка)
  # Почему 100? Позволяет кратковременно превысить ingestion_rate_mb.
  # Пример: обычно 10MB/sec, но может быть burst до 100MB/sec на 1 сек.
  ingestion_burst_size_mb: 100

  # Максимальное количество streams на пользователя
  # Что такое stream? Уникальная комбинация labels.
  # Пример: {app="chat", level="ERROR"} - один stream
  # Почему 0? Без ограничений (для тестирования).
  # Production: 10000 (защита от cardinality explosion)
  max_streams_per_user: 0

  # Максимальное количество streams глобально
  # Почему 0? Без ограничений.
  max_global_streams_per_user: 0

  # Отклонять старые логи?
  # Почему true? Защита от записи логов из прошлого (ошибки времени).
  reject_old_samples: true

  # Максимальный возраст логов для приема
  # Почему 168h? Соответствует retention_period.
  # Логи старше 7 дней не будут приняты.
  reject_old_samples_max_age: 168h

# ==================== COMPACTOR (сжатие и удаление старых логов) ====================
compactor:
  delete_request_store: filesystem
  # Рабочая директория для compactor
  # Зачем? Compactor создает временные файлы при работе.
  working_directory: /loki/compactor

  # Включить удаление старых логов (retention)?
  # Почему true? Иначе логи никогда не удалятся.
  retention_enabled: true

  # Задержка перед удалением
  # Почему 2h? Даем время для запросов к старым данным.
  # Если удалить сразу → возможны ошибки при чтении.
  retention_delete_delay: 2h

# ==================== QUERY RANGE (кэширование запросов) ====================
query_range:
  # Результаты запросов кэшируются?
  results_cache:
    cache:
      # Встроенный кэш (в памяти Loki)
      # Альтернативы: redis, memcached
      # Почему embedded? Проще для тестирования.
      embedded_cache:
        # Включен?
        # Почему true? Ускоряет повторные запросы.
        enabled: true

        # Максимальный размер кэша (MB)
        # Почему 100MB? Баланс между памятью и производительностью.
        # Если запросы повторяются → будут из кэша (быстро).
        max_size_mb: 100
