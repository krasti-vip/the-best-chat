auth_enabled: false

server:
  http_listen_address: 0.0.0.0
  http_listen_port: 3100

common:
  path_prefix: /loki
  storage:
    filesystem:
      chunks_directory: /loki/chunks
      rules_directory: /loki/rules
  replication_factor: 1
  ring:
    instance_addr: 127.0.0.1
    kvstore:
      store: inmemory

# ==================== SCHEMA CONFIG (схема индексов) (по каким параметрам будет проходить поиск логов)================
schema_config:
  configs:
    # Начиная с какой даты использовать эту схему
    # Почему 2024-01-01? Любая дата в прошлом.
    # Если изменить схему → новая дата + новая конфигурация.
    - from: 2024-01-01

      # Тип индекса: tsdb (Time Series Database)
      # Альтернативы: boltdb (старый), boltdb-shipper
      # Почему tsdb? Новый, быстрый, рекомендуется Grafana Labs.
      store: tsdb

      # Хранилище для chunks (нарезанные логи из промтэйла)
      # Почему filesystem? Соответствует common.storage
      object_store: filesystem

      # Версия схемы
      # Почему v13? Последняя стабильная версия.
      # v12, v11 - старые, не используйте.
      schema: v13

      # Настройки индекса
      index:
        # Префикс имени индекса
        # Почему index_? Просто соглашение, можно изменить.
        # Итоговое имя: index_19999 (где 19999 - период)
        prefix: index_

        # Период индекса (каждые 24 часа новый индекс)
        # Почему 24h? Баланс между количеством индексов и производительностью.
        # Альтернативы:
        # - 168h (7 дней) - меньше индексов, медленнее поиск
        # - 12h - больше индексов, быстрее поиск, больше overhead
        period: 24h

# ==================== LIMITS CONFIG (лимиты) ====================
limits_config:
  # Период хранения логов
  # Почему 168h (7 дней)? Для тестирования достаточно.
  # Production: 720h (30 дней) или больше.
  # После этого периода логи удаляются compactor'ом.
  retention_period: 168h

  # Максимальная скорость приема логов (MB/sec на tenant)
  # Почему 50? Достаточно для тестирования.
  # Пример: 50MB/sec = 4,320,000 MB/день = 4.32 TB/день
  # Если превышено → Loki откажет в записи логов.
  ingestion_rate_mb: 50

  # Burst размер (пиковая нагрузка)
  # Почему 100? Позволяет кратковременно превысить ingestion_rate_mb.
  # Пример: обычно 10MB/sec, но может быть burst до 100MB/sec на 1 сек.
  ingestion_burst_size_mb: 100

  # Максимальное количество streams на пользователя
  # Что такое stream? Уникальная комбинация labels.
  # Пример: {app="chat", level="ERROR"} - один stream
  # Почему 0? Без ограничений (для тестирования).
  # Production: 10000 (защита от cardinality explosion)
  max_streams_per_user: 0

  # Максимальное количество streams глобально
  # Почему 0? Без ограничений.
  max_global_streams_per_user: 0

  # Отклонять старые логи?
  # Почему true? Защита от записи логов из прошлого (ошибки времени).
  reject_old_samples: true

  # Максимальный возраст логов для приема
  # Почему 168h? Соответствует retention_period.
  # Логи старше 7 дней не будут приняты.
  reject_old_samples_max_age: 168h

# ==================== COMPACTOR (сжатие и удаление старых логов) ====================
compactor:
  delete_request_store: filesystem
  # Рабочая директория для compactor
  # Зачем? Compactor создает временные файлы при работе.
  working_directory: /loki/compactor

  # Включить удаление старых логов (retention)?
  # Почему true? Иначе логи никогда не удалятся.
  retention_enabled: true

  # Задержка перед удалением
  # Почему 2h? Даем время для запросов к старым данным.
  # Если удалить сразу → возможны ошибки при чтении.
  retention_delete_delay: 2h

# ==================== QUERY RANGE (кэширование запросов) ====================
query_range:
  # Результаты запросов кэшируются?
  results_cache:
    cache:
      # Встроенный кэш (в памяти Loki)
      # Альтернативы: redis, memcached
      # Почему embedded? Проще для тестирования.
      # Параметр для записи в КЭШ локально ->
      embedded_cache:
        # Включен?
        # Почему true? Ускоряет повторные запросы.
        enabled: true

        # Максимальный размер кэша (MB)
        # Почему 100MB? Баланс между памятью и производительностью.
        # Если запросы повторяются → будут из кэша (быстро).
        max_size_mb: 100



