# ==================== X-LOGGING (шаблон для логирования) ====================
# x-logging - это YAML якорь (anchor), который можно переиспользовать
# Зачем? Не повторять одинаковую конфигурацию для каждого сервиса
x-logging:
  &default-logging  # &default-logging - имя якоря
  # Docker log driver
  # json-file - логи в JSON файлы на хосте
  # Альтернативы: syslog, journald, none
  # Почему json-file? Promtail читает эти файлы.
  driver: "json-file"
  options:
    # Максимальный размер одного лог файла
    # Почему 10m (10 мегабайт)? Если файл больше → создается новый.
    # Защита от заполнения диска огромными логами.
    max-size: "10m"

    # Максимум файлов
    # Почему 3? Хранится 3 файла по 10MB = 30MB логов на контейнер.
    # Старые файлы удаляются автоматически.
    max-file: "3"

# ==================== NETWORKS ====================
networks:
  # Создаем сеть "app"
  # Зачем? Все контейнеры в одной сети могут общаться по именам.
  app:
    # Имя сети
    # Почему app? Просто соглашение, можно назвать как угодно.
    name: app
    # Драйвер сети
    # bridge - стандартный драйвер для Docker
    driver: bridge

# ==================== VOLUMES ====================
volumes:
  # Volumes - постоянное хранилище данных
  # Почему нужны? Контейнеры временные, при перезапуске данные теряются.
  # Volume сохраняет данные на хосте.

  # Volume для PostgreSQL
  postgres-data-new:

  # Volume для pgAdmin
  pgadmin-data:

  # Volume для Redis
  redis-data:

  # Volume для Loki (логи)
  loki-data:

# ==================== SERVICES ====================
services:

  # ==================== THE-BEST-CHAT (наше приложение) ====================
  the-best-chat:
    # Собрать образ из Dockerfile
    build:
      # Контекст сборки (корень проекта)
      context: .
      # Путь к Dockerfile
      dockerfile: Dockerfile

    # Имя контейнера
    # Почему важно? По этому имени будет фильтровать Promtail.
    container_name: the-best-chat

    # Переменные окружения
    environment:
      # Spring профиль
      # Почему docker? Чтобы использовать JSON логи (см. logback-spring.xml)
      SPRING_PROFILES_ACTIVE: docker

      # PostgreSQL
      # jdbc:postgresql://postgres:5432/postgres
      # postgres - имя контейнера (Docker DNS)
      # 5432 - порт PostgreSQL
      # postgres - имя базы данных
      POSTGRES_JDBC_URL: jdbc:postgresql://postgres:5432/postgres
      POSTGRES_USER: admin123
      POSTGRES_PASSWORD: admin123

      # Redis
      REDIS_HOST: redis  # имя контейнера
      REDIS_PORT: 6379
      REDIS_PASSWORD: 12345678
      REDIS_USER: myUser

    # Порты
    # "8080:8080" - хост:контейнер
    # Почему 8080? Стандартный порт Spring Boot.
    ports:
      - "8080:8080"

    # Зависимости (запускаться после этих сервисов)
    depends_on:
      # Ждать пока postgres станет healthy
      postgres:
        condition: service_healthy
      # Redis без condition (запустится просто)
      redis:
        condition: service_started

    # Сеть
    networks:
      - app

    # Логирование (используем якорь)
    logging: *default-logging  # *default-logging - ссылка на якорь

  # ==================== POSTGRES ====================
  postgres:
    container_name: postgres
    # Образ PostgreSQL версии 17.0
    # Почему 17.0? Последняя стабильная версия.
    image: postgres:17.0

    environment:
      # Пользователь PostgreSQL
      POSTGRES_USER: admin123
      # Пароль
      POSTGRES_PASSWORD: admin123
      # База данных (создается автоматически)
      POSTGRES_DB: postgres
      # Директория для данных внутри контейнера
      PGDATA: /data/postgres

    # Volumes - монтируем volume в контейнер
    # postgres-data:/data/postgres
    # postgres-data - имя volume (создан выше)
    # /data/postgres - путь внутри контейнера
    volumes:
      - postgres-data-new:/data/postgres

    # Порты
    # "4444:5432" - на хосте 4444, внутри контейнера 5432
    # Почему 4444? Чтобы не конфликтовать с локальным PostgreSQL на 5432.
    ports:
      - "4444:5432"

    networks:
      - app

    logging: *default-logging

    healthcheck:
      test: [ "CMD-SHELL", "pg_isready -U admin123 -d postgres" ]
      # -d postgres - явно указываем имя базы данных
      interval: 10s
      timeout: 5s
      retries: 5

  # ==================== PGADMIN ====================
  pgadmin:
    container_name: pgadmin
    # pgAdmin - веб-интерфейс для PostgreSQL
    image: dpage/pgadmin4:9.0

    environment:
      # Email для входа в pgAdmin
      PGADMIN_DEFAULT_EMAIL: admin@admin.example
      # Пароль для входа
      PGADMIN_DEFAULT_PASSWORD: admin
      # Режим сервера (False = desktop mode, проще для тестов)
      PGADMIN_CONFIG_SERVER_MODE: 'False'

    volumes:
      - pgadmin-data:/var/lib/pgadmin

    # Порт pgAdmin
    # Почему 5050? Стандартный порт, не конфликтует с другими.
    ports:
      - "5050:80"

    networks:
      - app

    logging: *default-logging

  # ==================== REDIS ====================
  redis:
    # Redis версии 7.2
    # Почему 7.2? Последняя стабильная версия.
    image: redis:7.2
    container_name: redis

    # Команда запуска с конфигом
    command: redis-server /usr/local/etc/redis/redis.conf

    ports:
      - "6379:6379"

    volumes:
      # Данные Redis
      - redis-data:/data
      # Конфигурация Redis
      - ./redis/redis.conf:/usr/local/etc/redis/redis.conf
      # ACL файл (пользователи и пароли)
      - ./redis/users.acl:/usr/local/etc/redis/users.acl

    networks:
      - app

    logging: *default-logging

  # ==================== LOKI ====================
  loki:
    # Loki версии 3.0.0 (latest на момент написания)
    image: grafana/loki:3.0.0
    container_name: loki

    # Команда запуска
    # -config.file=/etc/loki/loki-config.yaml - путь к конфигу
    command: -config.file=/etc/loki/loki-config.yaml

    # Порт Loki
    ports:
      - "3100:3100"

    volumes:
      # Конфигурация (read-only)
      # :ro - read-only (защита от случайного изменения из контейнера)
      - ./loki/loki.yaml:/etc/loki/loki-config.yaml:ro
      # Данные Loki (логи)
      - loki-data:/loki

    networks:
      - app

    logging: *default-logging

    # Healthcheck для Loki
    healthcheck:
      # wget - утилита для HTTP запросов
      # --no-verbose - без лишних логов
      # --tries=1 - одна попытка
      # --spider - не скачивать контент, только проверить доступность
      # /ready - endpoint Loki для проверки готовности
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3100/ready || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5

  # ==================== PROMTAIL ====================
  promtail:
    # Promtail версии 3.0.0 (совпадает с Loki)
    # Почему одинаковые версии? Гарантия совместимости.
    image: grafana/promtail:3.0.0
    container_name: promtail

    # Команда запуска
    command: -config.file=/etc/promtail/config.yaml

    volumes:
      # Конфигурация Promtail (read-only)
      - ./promtail/promtail.yaml:/etc/promtail/config.yaml:ro

      # Docker контейнеры (read-only)
      # /var/lib/docker/containers - где Docker хранит логи контейнеров
      # Почему read-only? Promtail только читает, не изменяет.
      - /var/lib/docker/containers:/var/lib/docker/containers:ro

      # Docker socket (read-only)
      # /var/run/docker.sock - Unix socket для Docker API
      # Зачем? Promtail использует Docker API для Service Discovery.
      - /var/run/docker.sock:/var/run/docker.sock:ro

    # Зависимости
    # Запускаться после Loki и дождаться его готовности
    depends_on:
      loki:
        condition: service_healthy

    networks:
      - app

    logging: *default-logging

  # ==================== GRAFANA ====================
  grafana:
    # Grafana latest (всегда последняя версия)
    # Альтернатива: указать конкретную версию (grafana:10.2.0)
    image: grafana/grafana:11.0.0
    container_name: grafana

    environment:
      # Анонимный доступ (без логина)
      # Почему true? Для тестирования удобнее без авторизации.
      # Production: false (нужен логин/пароль)
      - GF_AUTH_ANONYMOUS_ENABLED=true

      # Роль анонимного пользователя
      # Admin - полный доступ ко всем функциям
      # Альтернативы: Viewer (только просмотр), Editor (изменение дашбордов)
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Admin

      # Feature toggles (экспериментальные функции)
      # lokiLogsDataplane - новый UI для логов (быстрее, удобнее)
      - GF_FEATURE_TOGGLES_ENABLE=lokiLogsDataplane

    volumes:
      # Datasources (автоматическая настройка Loki)
      - ./grafana/grafana.yaml:/etc/grafana/provisioning/datasources/datasources.yaml:ro

    # Порт Grafana
    # Почему 3000? Стандартный порт Grafana.
    ports:
      - "3000:3000"

    # Зависимости
    depends_on:
      loki:
        condition: service_healthy

    networks:
      - app

    logging: *default-logging

    # Healthcheck для Grafana
    healthcheck:
      # /api/health - endpoint Grafana для проверки здоровья
      test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/api/health || exit 1"]
      interval: 10s
      timeout: 5s
      retries: 5